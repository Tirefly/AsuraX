// Copyright 2021 Mickael Daniel. All Rights Reserved.

#include "K2Node/FireflyK2Node_SwitchGameplayAttribute.h"

#include "FireflyAbilitySystemLibrary.h"
#include "BlueprintActionDatabaseRegistrar.h"
#include "BlueprintNodeSpawner.h"
#include "EdGraphSchema_K2.h"
#include "Engine/Blueprint.h"


UFireflyK2Node_SwitchGameplayAttribute::UFireflyK2Node_SwitchGameplayAttribute(const FObjectInitializer& ObjectInitializer)
	: Super(ObjectInitializer)
{
	FunctionName = TEXT("NotEqual_AttributeAttribute");
	FunctionClass = UFireflyAbilitySystemLibrary::StaticClass();
	OrphanedPinSaveMode = ESaveOrphanPinMode::SaveNone;
}

void UFireflyK2Node_SwitchGameplayAttribute::AddPinToSwitchNode()
{
	// 获取唯一的引脚名称
	// Get a unique pin name
	const FName PinName = GetUniquePinName();
	PinNames.Add(PinName);

	// 创建一个输出引脚
	// Create an output pin
	UEdGraphPin* NewPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, PinName);
	NewPin->bAllowFriendlyName = false;
	NewPin->PinFriendlyName = FText::FromName(PinName);

	// 如果属性数量少于引脚名称数量，添加一个默认的 Gameplay 属性
	// If there are fewer attributes than pin names, add a default Gameplay attribute
	if (PinAttributes.Num() < PinNames.Num())
	{
		PinAttributes.Add(FGameplayAttribute());
	}

}

FName UFireflyK2Node_SwitchGameplayAttribute::GetUniquePinName()
{
	// 生成新的引脚名称，确保唯一性
	// Generate a new pin name, ensuring uniqueness
	FName NewPinName;
	int32 Index = 0;
	while (true)
	{
		NewPinName = *FString::Printf(TEXT("Case_%d"), Index++);
		if (!FindPin(NewPinName))
		{
			break;
		}
	}
	return NewPinName;
}

FEdGraphPinType UFireflyK2Node_SwitchGameplayAttribute::GetPinType() const
{
	// 创建一个属性类型的引脚
	// Create an attribute type pin
	FEdGraphPinType PinType;
	PinType.PinCategory = UEdGraphSchema_K2::PC_Struct;
	PinType.PinSubCategoryObject = FGameplayAttribute::StaticStruct();

	return PinType;
}

FEdGraphPinType UFireflyK2Node_SwitchGameplayAttribute::GetInnerCaseType() const
{
	// 这个类型应该与 UFireflyAbilitySystemLibrary::NotEqual_AttributeAttribute 的第二个参数匹配！
	// This type should match the second argument of UFireflyAbilitySystemLibrary::NotEqual_AttributeAttribute !
	FEdGraphPinType PinType;
	PinType.PinCategory = UEdGraphSchema_K2::PC_String;
	return PinType;
}

FName UFireflyK2Node_SwitchGameplayAttribute::GetPinNameGivenIndex(int32 Index) const
{
	check(Index);
	return PinNames[Index];
}

void UFireflyK2Node_SwitchGameplayAttribute::CreateFunctionPin()
{
	// 在函数引脚上设置属性
	// Set properties on the function pin
	UEdGraphPin* FunctionPin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Object, FunctionClass, FunctionName);
	FunctionPin->bDefaultValueIsReadOnly = true;
	FunctionPin->bNotConnectable = true;
	FunctionPin->bHidden = true;

	// 查找函数对象并检查是否为静态函数
	// Find the function object and check if it's a static function
	UFunction* Function = FindUField<UFunction>(FunctionClass, FunctionName);
	const bool bIsStaticFunc = Function->HasAllFunctionFlags(FUNC_Static);

	if (bIsStaticFunc)
	{
		// 如果是静态函数，将 self 链接到类的默认对象（如果不是当前类的默认对象）
		// If it's a static function, wire up the self to the CDO of the class (if not the CDO of our class)
		if (UBlueprint* BP = GetBlueprint())
		{
			UClass* FunctionOwnerClass = Function->GetOuterUClass();
			if (!BP->SkeletonGeneratedClass->IsChildOf(FunctionOwnerClass))
			{
				FunctionPin->DefaultObject = FunctionOwnerClass->GetDefaultObject();
			}
		}
	}
}

void UFireflyK2Node_SwitchGameplayAttribute::CreateSelectionPin()
{
	// 获取默认的 K2 图谱模式
	// Get the default K2 graph schema
	const UEdGraphSchema_K2* K2Schema = GetDefault<UEdGraphSchema_K2>();

	// 创建一个输入引脚，并使用结构体 FGameplayAttribute 作为类型，命名为 "Selection"
	// Create an input pin with the type of structure FGameplayAttribute and name it "Selection"
	UEdGraphPin* Pin = CreatePin(EGPD_Input, UEdGraphSchema_K2::PC_Struct, FGameplayAttribute::StaticStruct(), TEXT("Selection"));

	// 基于类型设置引脚的自动生成默认值
	// Set the autogenerated default value for the pin based on its type
	K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(Pin);
}

void UFireflyK2Node_SwitchGameplayAttribute::CreateCasePins()
{
	// 确保引脚名称数量不超过属性数量
	// Ensure that the number of pin names does not exceed the number of attributes
	while (PinAttributes.Num() > PinNames.Num())
	{
		const FName PinName = GetUniquePinName();
		PinNames.Add(PinName);
	}

	// 如果引脚名称数量超过属性数量，将引脚名称数量截断为与属性数量相等
	// If the number of pin names exceeds the number of attributes, truncate the number of pin names to match the number of attributes
	if (PinNames.Num() > PinAttributes.Num())
	{
		PinNames.SetNum(PinAttributes.Num());
	}

	for (int32 Index = 0; Index < PinAttributes.Num(); ++Index)
	{
		if (PinAttributes[Index].IsValid())
		{
			// 如果属性有效，将引脚名称设置为属性的名称
			// If the attribute is valid, set the pin name to the attribute's name
			PinNames[Index] = *PinAttributes[Index].GetName();
		}
		else
		{
			// 如果属性无效，生成唯一的引脚名称
			// If the attribute is invalid, generate a unique pin name
			PinNames[Index] = GetUniquePinName();
		}

		// 创建输出引脚并设置友好名称
		// Create an output pin and set its friendly name
		UEdGraphPin* NewPin = CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, PinNames[Index]);
		NewPin->bAllowFriendlyName = false;
		if (PinAttributes[Index].IsValid())
		{
			FGameplayAttribute Attribute = PinAttributes[Index];
			FString FriendlyName = Attribute.GetAttributeSetClass()->GetName() + "." + Attribute.GetName();
			NewPin->PinFriendlyName = FText::FromString(FriendlyName);
		}
		else
		{
			NewPin->PinFriendlyName = FText::FromName(PinNames[Index]);
		}
	}

}

void UFireflyK2Node_SwitchGameplayAttribute::RemovePin(UEdGraphPin* TargetPin)
{
	// 检查 TargetPin 是否为有效引脚
	// Check if TargetPin is a valid pin
	checkSlow(TargetPin);

	// 获取 TargetPin 的引脚名称
	// Get the pin name of TargetPin
	FName PinName = TargetPin->PinName;

	// 清理引脚名称数组
	// Clean-up the pin name array
	int32 Index = PinNames.IndexOfByKey(PinName);
	if (Index >= 0)
	{
		if (Index < PinAttributes.Num())
		{
			PinAttributes.RemoveAt(Index);
		}
		PinNames.RemoveAt(Index);
	}

}

void UFireflyK2Node_SwitchGameplayAttribute::GetMenuActions(FBlueprintActionDatabaseRegistrar& ActionRegistrar) const
{
	// 操作被注册在特定的对象键下；想法是，如果它们的对象键发生变化（或被删除），则操作可能需要更新（或删除）
	// 这里我们使用节点的类（因此，如果节点类型消失，则操作也应随之消失）
	// Actions get registered under specific object-keys; the idea is that actions might have to be updated (or deleted) if their object-key is mutated (or removed)
	// Here we use the node's class (so if the node type disappears, then the action should go with it)
	UClass* ActionKey = GetClass();

	// 为了避免不必要地实例化 UBlueprintNodeSpawner，首先检查注册器是否正在寻找此类型的操作
	// （可能正在为特定资产重新生成操作，因此注册器只接受与该资产对应的操作）
	// To keep from needlessly instantiating a UBlueprintNodeSpawner, first check to make sure that the registrar is looking for actions of this type
	// (could be regenerating actions for a specific asset, and therefore the registrar would only accept actions corresponding to that asset)
	if (ActionRegistrar.IsOpenForRegistration(ActionKey))
	{
		UBlueprintNodeSpawner* NodeSpawner = UBlueprintNodeSpawner::Create(GetClass());
		check(NodeSpawner != nullptr);

		ActionRegistrar.AddBlueprintAction(ActionKey, NodeSpawner);
	}
}

FText UFireflyK2Node_SwitchGameplayAttribute::GetTooltipText() const
{
	return NSLOCTEXT("K2Node", "SwitchGameplayAttribute_ToolTip", "Selects an output that matches the input value");
}

FText UFireflyK2Node_SwitchGameplayAttribute::GetNodeTitle(ENodeTitleType::Type TitleType) const
{
	return NSLOCTEXT("K2Node", "Switch_GameplayAttribute", "Switch on Gameplay Attribute");
}

void UFireflyK2Node_SwitchGameplayAttribute::PostEditChangeProperty(struct FPropertyChangedEvent& PropertyChangedEvent)
{
	// 标志是否已修改
	// Flag to indicate if changes have been made
	bool bIsDirty = false;

	// 获取属性的名称
	const FName PropertyName = (PropertyChangedEvent.Property ? PropertyChangedEvent.Property->GetFName() : NAME_None);

	// 检查是否属性名称为 "PinAttributes" 或 "AttributeName"
	if (PropertyName == GET_MEMBER_NAME_CHECKED(UFireflyK2Node_SwitchGameplayAttribute, PinAttributes) || PropertyName == FName("AttributeName"))
	{
		bIsDirty = true;
	}

	// 如果已修改，重建节点并通知图表已更改
	if (bIsDirty)
	{
		ReconstructNode();
		GetGraph()->NotifyGraphChanged();
	}

	// 调用父类的 PostEditChangeProperty 函数
	Super::PostEditChangeProperty(PropertyChangedEvent);

}

void UFireflyK2Node_SwitchGameplayAttribute::PostLoad()
{
	Super::PostLoad();

	// 如果找到了具有指定名称的引脚，将其默认对象设置为函数类的默认对象
	// If a pin with the specified name is found, set its default object to the default object of the function class
	if (UEdGraphPin* FunctionPin = FindPin(FunctionName))
	{
		FunctionPin->DefaultObject = FunctionClass->GetDefaultObject();
	}

}